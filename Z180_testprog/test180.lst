# File test180.z80
0000			; Test program for the Z180 computer 
0000			; test180.z80 
0000			; 
0000			; testing: 
0000			;   - simple MMU setup 
0000			;   - RAM as stack 
0000			;   - Serial output port 0 & 1 
0000			;   - Serial input port 0 & 1 
0000			;   - MMU setup with Common Bank 0, Bank Area, Common Bank 1 
0000			;   - simple RAM test 
0000			;   - copy test program to RAM and execute 
0000			;   - switch to low RAM using MEMSEL 
0000			;   - test 74LS74 select outputs 
0000			; todo 
0000			;   - test all RAM using MEMSEL 
0000			;   - interupt test 
0000			 
0000			; Internal ports 
0000			 
0000			; ASCI Registers port 0 and 1 
0000			CNTLA0: equ 0x0000  ;ASCI Channel Control Register A 0 
0000			CNTLA1: equ 0x0001  ;ASCI Channel Control Register A 1 
0000			CNTLB0: equ 0x0002  ;ASCI Control Register B 0 
0000			CNTLB1: equ 0x0003  ;ASCI Control Register B 1 
0000			STAT0:  equ 0x0004  ;ASCI Status Register 0 
0000			STAT1:  equ 0x0005  ;ASCI Status Register 1 
0000			TDR0:   equ 0x0006  ;ASCI Transmit Data Register 0 
0000			TDR1:   equ 0x0007  ;ASCI Transmit Data Register 1 
0000			RDR0:   equ 0x0008  ;ASCI Receive Data FIFO 0 
0000			RDR1:   equ 0x0009  ;ASCI Receive Data FIFO 1 
0000			 
0000			; MMU Registers 
0000			CBR:    equ 0x0038  ;MMU Common Base Register 
0000			BBR:    equ 0x0039  ;MMU Bank Base Register 
0000			CBAR:   equ 0x003a  ;MMU Common/Bank Area Register 
0000			 
0000			; External ports 
0000			 
0000			;Select EPROM or RAM on address 0x0000 - 0x3ffff 
0000			ROMSEL: equ 0x40    ;Write selects EPROM (reset condition) 
0000			RAMSEL: equ 0x41    ;Write selects RAM 
0000			 
0000			;LED on/off 
0000			LEDOFF: equ 0x42    ;Write turns LED off (reset condition) 
0000			LEDON:  equ 0x43    ;Write turns LED on 
0000			 
0000			;SPI device select and AVR reset 
0000			CSPORT: equ 0x44    ;Write to bit 0 - 3 (reset condition, all 0) 
0000			                    ;Bit 0: select SD_CS0 when set to 1 
0000			                    ;Bit 1: select SD_CS1 when set to 1 
0000			                    ;Bit 2: select ATSS (AVR) when set to 1 
0000			                    ;Bit 1: reset AVR when set to 1 
0000			                    ;       if JP8 pin 2-3 connected 
0000			 
0000			 
0000			boot: 
0000			 
0000			init: 
0000			 
0000			; Set up the MMU 
0000			; 
0000			; Common Bank 0, 4KB 
0000			;    logical: 0x0000 - 0x0fff 
0000			;    physical: 0x00000 - 0x00fff, EPROM or start of low RAM if enabled 
0000			; Bank Area, 56KB 
0000			;    logical: 0x1000 - 0xefff 
0000			;    physical: 0x41000 - 0x4efff, low RAM chip above EPROM 
0000			; Common Bank 1, 4KB 
0000			;    logical: 0xf000 - 0xffff 
0000			;    physical: 0xff000 - 0xfffff, end of high RAM chip 
0000			; 
0000			; The MMU function is a bit mysterious but I learned that CBAR 
0000			; must be configured before CBR and BBR otherwise strange 
0000			; things will happen. 
0000			 
0000 3e f1		    ld a, 0xf1   ;<CA><BA> 
0002 01 3a 00		    ld bc, CBAR 
0005 ed 79		    out (c), a 
0007 3e f0		    ld a, 0xf0 
0009 01 38 00		    ld bc, CBR 
000c ed 79		    out (c), a 
000e 3e 40		    ld a, 0x40 
0010 01 39 00		    ld bc, BBR 
0013 ed 79		    out (c), a 
0015			 
0015			HIRAM: equ 0xf000 
0015			 
0015			; copy the program to high RAM 
0015 01 c9 01		    ld bc,prgend - prgstart 
0018 21 2e 00		    ld hl,prgineprom 
001b 11 00 f0		    ld de,HIRAM 
001e			cploop: 
001e 78			    ld a,b 
001f b1			    or c 
0020 ca 2b 00		    jp z,cpend 
0023 7e			    ld a,(hl) 
0024 23			    inc hl 
0025 12			    ld (de),a 
0026 13			    inc de 
0027 0b			    dec bc 
0028 c3 1e 00		    jp cploop 
002b			cpend: 
002b c3 00 f0		    jp HIRAM	; jump to the copied code 
002e			 
002e			prgineprom: 
002e			 
002e			    org HIRAM 
f000			 
f000			prgstart: 
f000			 
f000			; Set up Stack Pointer (first push/call will wrap to 0xffff) 
f000 31 00 00		    ld sp, 0x0000 
f003			 
f003			; Initialize devices 
f003			; and blink LED 
f003			 
f003 06 01		    ld b, 1         ;1 blink, MMU initialized 
f005 cd aa f0		    call ledblink 
f008 06 02		    ld b, 2 
f00a cd c7 f0		    call delays 
f00d			 
f00d cd 34 f0		    call asci0init 
f010 06 02		    ld b, 2         ;2 blinks, ASCI 0 initialized 
f012 cd aa f0		    call ledblink 
f015 06 02		    ld b, 2 
f017 cd c7 f0		    call delays 
f01a			 
f01a cd 6f f0		    call asci1init 
f01d 06 03		    ld b, 3         ;3 blinks, ASCI 1 initialized 
f01f cd aa f0		    call ledblink 
f022 06 02		    ld b, 2 
f024 cd c7 f0		    call delays 
f027			 
f027 3e 00		    ld a, 0 
f029 32 c9 f1		    ld (indindex), a 
f02c			 
f02c 3e 11		    ld a, 00010001b 
f02e 32 ca f1		    ld (cspattern), a 
f031			 
f031 c3 dc f0		    jp testloop 
f034			 
f034			; ASCI routines 
f034			 
f034			; Initialize port 0 
f034			asci0init: 
f034 3e 64		    ld a, 01100100b 
f036			            ; bit 7 = 0: MPE - disabled 
f036			            ; bit 6 = 1: RE - Rx enabled 
f036			            ; bit 5 = 1: TE - Tx enabled 
f036			            ; bit 4 = 0: RTS0 - set to low, RTS active (?) 
f036			            ; bit 3 = 0: MPBR/EFR - not used 
f036			            ; bit 2 - 0 = 100 - Start + 8 bit data + 1 stop 
f036 01 00 00		    ld bc, CNTLA0 
f039 ed 79		    out (c), a 
f03b			 
f03b			    ; set Baudrate: PHI / (PS * DR * SS) = Baud Rate 
f03b			    ; 9216000 Hz / (30 * 16 * 2) = 9600 Baud 
f03b 3e 21		    ld a, 00100001b 
f03d			            ; bit 7 = 0:  MPBT - disabled 
f03d			            ; bit 6 = 0:  MP - disabled 
f03d			            ; bit 5 = 1:  CTS/PS - prescale = 30 (PS as SS2-0 are not 111) 
f03d			            ; bit 4 = 0:  PEO - ignored as no parity configured 
f03d			            ; bit 3 = 0:  DR - Clock factor = 16 
f03d			            ; bit 2 - 0 = 001:  SS2-SS0 - Divide Ratio: 2 
f03d 01 02 00		    ld bc, CNTLB0 
f040 ed 79		    out (c), a 
f042			 
f042 c9			    ret 
f043			 
f043			; Output a character on port 0 
f043			; reg E contains character to output 
f043			asci0putc: 
f043 01 04 00		    ld bc, STAT0 
f046 ed 78		    in a, (c) 
f048 e6 02		    and 00000010b    ;test bit 1 = TDRE: Transmit Data Register Empty 
f04a 28 f7		    jr z, asci0putc  ;not empty yet 
f04c 7b			    ld a, e 
f04d 01 06 00		    ld bc, TDR0 
f050 ed 79		    out (c), a       ;output character 
f052 c9			    ret 
f053			 
f053			; Input a character from port 0 
f053			; reg E contains the character 
f053			; if E == 0 no character is available 
f053			asci0getc: 
f053 1e 00		    ld e, 0 
f055 01 04 00		    ld bc, STAT0 
f058 ed 78		    in a, (c) 
f05a e6 80		    and 10000000b    ;test bit 7 = RDRF: Recieve data in FIFO 
f05c c8			    ret z            ;empty 
f05d 7b			    ld a, e 
f05e 01 08 00		    ld bc, RDR0 
f061 ed 78		    in a, (c)        ;input character 
f063 5f			    ld e, a 
f064 c9			    ret 
f065			 
f065			; Output a character string on port 0 
f065			; reg HL points to string to output 
f065			; the string is ended by 0 
f065			asci0pstr: 
f065 7e			    ld a, (hl) 
f066 b7			    or a 
f067 c8			    ret z 
f068 5e			    ld e, (hl) 
f069 23			    inc hl 
f06a cd 43 f0		    call asci0putc 
f06d 18 f6		    jr asci0pstr 
f06f			 
f06f			; Initialize port 1 
f06f			asci1init: 
f06f 3e 64		    ld a, 01100100b 
f071			            ; bit 7 = 0: MPE - disabled 
f071			            ; bit 6 = 1: RE - Rx enabled 
f071			            ; bit 5 = 1: TE - Tx enabled 
f071			            ; bit 4 = 0: RTS0 - set to low, RTS active (?) 
f071			            ; bit 3 = 0: MPBR/EFR - not used 
f071			            ; bit 2 - 0 = 100 - Start + 8 bit data + 1 stop 
f071 01 01 00		    ld bc, CNTLA1 
f074 ed 79		    out (c), a 
f076			 
f076			    ; set Baudrate: PHI / (PS * DR * SS) = Baud Rate 
f076			    ; 9216000 Hz / (30 * 16 * 2) = 9600 Baud 
f076 3e 21		    ld a, 00100001b 
f078			            ; bit 7 = 0:  MPBT - disabled 
f078			            ; bit 6 = 0:  MP - disabled 
f078			            ; bit 5 = 1:  CTS/PS - prescale = 30 (PS as SS2-0 are not 111) 
f078			            ; bit 4 = 0:  PEO - ignored as no parity configured 
f078			            ; bit 3 = 0:  DR - Clock factor = 16 
f078			            ; bit 2 - 0 = 001:  SS2-SS0 - Divide Ratio: 2 
f078 01 03 00		    ld bc, CNTLB1 
f07b ed 79		    out (c), a 
f07d			 
f07d c9			    ret 
f07e			 
f07e			; Output a character on port 1 
f07e			; reg E contains character to output 
f07e			asci1putc: 
f07e 01 05 00		    ld bc, STAT1 
f081 ed 78		    in a, (c) 
f083 e6 02		    and 00000010b    ;test bit 1 = TDRE: Transmit Data Register Empty 
f085 28 f7		    jr z, asci1putc  ;not empty yet 
f087 7b			    ld a, e 
f088 01 07 00		    ld bc, TDR1 
f08b ed 79		    out (c), a       ;output character 
f08d c9			    ret 
f08e			 
f08e			; Input a character from port 1 
f08e			; reg E contains the character 
f08e			; if E == 0 no character is available 
f08e			asci1getc: 
f08e 1e 00		    ld e, 0 
f090 01 05 00		    ld bc, STAT1 
f093 ed 78		    in a, (c) 
f095 e6 80		    and 10000000b    ;test bit 7 = RDRF: Recieve data in FIFO 
f097 c8			    ret z            ;empty 
f098 7b			    ld a, e 
f099 01 09 00		    ld bc, RDR1 
f09c ed 78		    in a, (c)        ;input character 
f09e 5f			    ld e, a 
f09f c9			    ret 
f0a0			 
f0a0			; Output a character string on port 1 
f0a0			; reg HL points to string to output 
f0a0			; the string is ended by 0 
f0a0			asci1pstr: 
f0a0 7e			    ld a, (hl) 
f0a1 b7			    or a 
f0a2 c8			    ret z 
f0a3 5e			    ld e, (hl) 
f0a4 23			    inc hl 
f0a5 cd 7e f0		    call asci1putc 
f0a8 18 f6		    jr asci1pstr 
f0aa			 
f0aa			; ledblink flashes the LED 
f0aa			; number of times in B reg 
f0aa			; using reg: a, b, hl 
f0aa			ledblink: 
f0aa 21 ff ff		    ld hl, 0xffff 
f0ad 3e 01		    ld a, 1 
f0af d3 43		    out(LEDON), a 
f0b1			ledonloop: 
f0b1 2b			    dec hl 
f0b2 7c			    ld a, h 
f0b3 b5			    or l 
f0b4 c2 b1 f0		    jp nz, ledonloop 
f0b7 21 ff ff		    ld hl, 0xffff 
f0ba 3e 00		    ld a, 0 
f0bc d3 42		    out(LEDOFF), a 
f0be			ledoffloop: 
f0be 2b			    dec hl 
f0bf 7c			    ld a, h 
f0c0 b5			    or l 
f0c1 c2 be f0		    jp nz, ledoffloop 
f0c4 10 e4		    djnz ledblink 
f0c6 c9			    ret 
f0c7			 
f0c7			; delays makes a delay multiplied 
f0c7			; by number of times in B reg 
f0c7			; using reg: a, b, hl 
f0c7			delays: 
f0c7 21 ff ff		    ld hl, 0xffff 
f0ca			delay1loop: 
f0ca 2b			    dec hl 
f0cb 7c			    ld a, h 
f0cc b5			    or l 
f0cd c2 ca f0		    jp nz, delay1loop 
f0d0 21 ff ff		    ld hl, 0xffff 
f0d3			delay2loop: 
f0d3 2b			    dec hl 
f0d4 7c			    ld a, h 
f0d5 b5			    or l 
f0d6 c2 d3 f0		    jp nz, delay2loop 
f0d9 10 ec		    djnz delays 
f0db c9			    ret 
f0dc			 
f0dc			; Main test loop 
f0dc			testloop: 
f0dc 06 01		    ld b, 1 
f0de cd aa f0		    call ledblink 
f0e1 06 01		    ld b, 1 
f0e3 cd c7 f0		    call delays 
f0e6			 
f0e6 3e 01		    ld a, 1 
f0e8 d3 41		    out (RAMSEL), a 
f0ea 06 02		    ld b, 2 
f0ec cd c7 f0		    call delays 
f0ef 3e 01		    ld a, 1 
f0f1 d3 40		    out (ROMSEL), a 
f0f3			 
f0f3 21 5e f1		    ld hl, asci0txt 
f0f6 cd 65 f0		    call asci0pstr 
f0f9 21 78 f1		    ld hl, indicator 
f0fc 06 00		    ld b, 0 
f0fe 3a c9 f1		    ld a, (indindex) 
f101 4f			    ld c, a 
f102 09			    add hl, bc 
f103 5e			    ld e, (hl) 
f104 cd 43 f0		    call asci0putc 
f107 21 7c f1		    ld hl, built 
f10a cd 65 f0		    call asci0pstr 
f10d cd 53 f0		    call asci0getc 
f110 7b			    ld a, e 
f111 b7			    or a 
f112 ca 1e f1		    jp z, asci0noin 
f115 cd 43 f0		    call asci0putc 
f118 21 b6 f1		    ld hl, inptxt 
f11b cd 65 f0		    call asci0pstr 
f11e			asci0noin: 
f11e			 
f11e 21 6b f1		    ld hl, asci1txt 
f121 cd a0 f0		    call asci1pstr 
f124 21 78 f1		    ld hl, indicator 
f127 06 00		    ld b, 0 
f129 3a c9 f1		    ld a, (indindex) 
f12c 4f			    ld c, a 
f12d 09			    add hl, bc 
f12e 5e			    ld e, (hl) 
f12f cd 7e f0		    call asci1putc 
f132 21 7c f1		    ld hl, built 
f135 cd a0 f0		    call asci1pstr 
f138 cd 8e f0		    call asci1getc 
f13b 7b			    ld a, e 
f13c b7			    or a 
f13d ca 49 f1		    jp z, asci1noin 
f140 cd 7e f0		    call asci1putc 
f143 21 b6 f1		    ld hl, inptxt 
f146 cd a0 f0		    call asci1pstr 
f149			asci1noin: 
f149			 
f149			;Indicator index for messages 
f149			 
f149 3a c9 f1		    ld a, (indindex) 
f14c 3c			    inc a 
f14d e6 03		    and 00000011b 
f14f 32 c9 f1		    ld (indindex), a 
f152			 
f152			;Chip Select and reset output 
f152 3a ca f1		    ld a, (cspattern) 
f155 d3 44		    out (CSPORT), a 
f157 07			    rlca 
f158 32 ca f1		    ld (cspattern), a 
f15b			 
f15b c3 dc f0		    jp testloop 
f15e			 
f15e			asci0txt: 
f15e ..			    db "ASCI port 0 " 
f16a 00			    db 0 
f16b			asci1txt: 
f16b ..			    db "ASCI port 1 " 
f177 00			    db 0 
f178			 
f178			indicator: 
f178 .. 2f 2d 5c	    db '|', '/', '-', '\\' 
f17c			 
f17c			built: 
f17c ..			    db " Test program for Z180 computer" 
f19b			    include "tbuilt180.z80" 
f19b ..			    db ", built 2021-08-21 16:54" 
# End of file tbuilt180.z80
f1b3 .. 0a		    db '\r', '\n' 
f1b5 00			    db 0 
f1b6			 
f1b6			inptxt: 
f1b6 ..			    db " <- was recieved" 
f1c6 .. 0a		    db '\r', '\n' 
f1c8 00			    db 0 
f1c9			 
f1c9			prgend: 
f1c9			 
f1c9			indindex: 
f1c9 00			    db 0 
f1ca			 
f1ca			cspattern: 
f1ca 00			    db 0 
f1cb			 
# End of file test180.z80
f1cb
