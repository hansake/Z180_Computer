# File test180.z80
0000			; Test program for the Z180 computer 
0000			; test180.z80 
0000			; 
0000			; testing: 
0000			;   - simple MMU setup 
0000			;   - RAM as stack 
0000			;   - Serial output port 0 & 1 
0000			;   - Serial input port 0 & 1 
0000			;   - MMU setup with Common Bank 0, Bank Area, Common Bank 1 
0000			;   - simple RAM test 
0000			;   - copy test program to RAM and execute 
0000			;   - switch to low RAM using MEMSEL 
0000			;   - test 74LS74 select outputs 
0000			;   - test all RAM using MMU and MEMSEL 
0000			; todo 
0000			;   - interupt test 
0000			 
0000			; Internal ports 
0000			 
0000			; ASCI Registers port 0 and 1 
0000			CNTLA0: equ 0x0000  ;ASCI Channel Control Register A 0 
0000			CNTLA1: equ 0x0001  ;ASCI Channel Control Register A 1 
0000			CNTLB0: equ 0x0002  ;ASCI Control Register B 0 
0000			CNTLB1: equ 0x0003  ;ASCI Control Register B 1 
0000			STAT0:  equ 0x0004  ;ASCI Status Register 0 
0000			STAT1:  equ 0x0005  ;ASCI Status Register 1 
0000			TDR0:   equ 0x0006  ;ASCI Transmit Data Register 0 
0000			TDR1:   equ 0x0007  ;ASCI Transmit Data Register 1 
0000			RDR0:   equ 0x0008  ;ASCI Receive Data FIFO 0 
0000			RDR1:   equ 0x0009  ;ASCI Receive Data FIFO 1 
0000			 
0000			; MMU Registers 
0000			CBR:    equ 0x0038  ;MMU Common Base Register 
0000			BBR:    equ 0x0039  ;MMU Bank Base Register 
0000			CBAR:   equ 0x003a  ;MMU Common/Bank Area Register 
0000			 
0000			; External ports 
0000			 
0000			;Select EPROM or RAM on address 0x0000 - 0x3ffff 
0000			ROMSEL: equ 0x40    ;Write selects EPROM (reset condition) 
0000			RAMSEL: equ 0x41    ;Write selects RAM 
0000			 
0000			;LED on/off 
0000			LEDOFF: equ 0x42    ;Write turns LED off (reset condition) 
0000			LEDON:  equ 0x43    ;Write turns LED on 
0000			 
0000			;SPI device select and AVR reset 
0000			CSPORT: equ 0x44    ;Write to bit 0 - 3 (reset condition, all 0) 
0000			                    ;Bit 0: select SD_CS0 when set to 1 
0000			                    ;Bit 1: select SD_CS1 when set to 1 
0000			                    ;Bit 2: select ATSS (AVR) when set to 1 
0000			                    ;Bit 1: reset AVR when set to 1 
0000			                    ;       if JP8 pin 2-3 connected 
0000			 
0000			 
0000			boot: 
0000			 
0000			init: 
0000			 
0000			; Set up the MMU initially 
0000			; 
0000			; Common Bank 0, 4KB 
0000			;    logical: 0x0000 - 0x0fff 
0000			;    physical: 0x00000 - 0x00fff, EPROM or start of low RAM if enabled 
0000			; Bank Area, 56KB 
0000			;    logical: 0x1000 - 0xefff 
0000			;    physical: 0x41000 - 0x4efff, low RAM chip above EPROM 
0000			; Common Bank 1, 4KB 
0000			;    logical: 0xf000 - 0xffff 
0000			;    physical: 0xff000 - 0xfffff, end of high RAM chip 
0000			; 
0000			; The MMU function is a bit mysterious but I learned that CBAR 
0000			; must be configured before CBR and BBR otherwise strange 
0000			; things will happen. 
0000			 
0000 3e f1		    ld a, 0xf1   ;<CA><BA> 
0002 01 3a 00		    ld bc, CBAR 
0005 ed 79		    out (c), a 
0007 3e f0		    ld a, 0xf0 
0009 01 38 00		    ld bc, CBR 
000c ed 79		    out (c), a 
000e 3e 40		    ld a, 0x40 
0010 01 39 00		    ld bc, BBR 
0013 ed 79		    out (c), a 
0015			 
0015			HIRAM: equ 0xf000 
0015			 
0015			; copy the program to high RAM 
0015 01 8f 05		    ld bc,prgend - prgstart 
0018 21 2e 00		    ld hl,prgineprom 
001b 11 00 f0		    ld de,HIRAM 
001e			cploop: 
001e 78			    ld a,b 
001f b1			    or c 
0020 ca 2b 00		    jp z,cpend 
0023 7e			    ld a,(hl) 
0024 23			    inc hl 
0025 12			    ld (de),a 
0026 13			    inc de 
0027 0b			    dec bc 
0028 c3 1e 00		    jp cploop 
002b			cpend: 
002b c3 00 f0		    jp HIRAM	; jump to the copied code 
002e			 
002e			prgineprom: 
002e			 
002e			    org HIRAM 
f000			 
f000			prgstart: 
f000			 
f000			; Set up Stack Pointer (first push/call will wrap to 0xffff) 
f000 31 00 00		    ld sp, 0x0000 
f003			 
f003			; Initialize devices 
f003			; and blink LED 
f003			 
f003 06 01		    ld b, 1         ;1 blink, MMU initialized 
f005 cd aa f0		    call ledblink 
f008 06 02		    ld b, 2 
f00a cd c7 f0		    call delays 
f00d			 
f00d cd 34 f0		    call asci0init 
f010 06 02		    ld b, 2         ;2 blinks, ASCI 0 initialized 
f012 cd aa f0		    call ledblink 
f015 06 02		    ld b, 2 
f017 cd c7 f0		    call delays 
f01a			 
f01a cd 6f f0		    call asci1init 
f01d 06 03		    ld b, 3         ;3 blinks, ASCI 1 initialized 
f01f cd aa f0		    call ledblink 
f022 06 02		    ld b, 2 
f024 cd c7 f0		    call delays 
f027			 
f027 3e 00		    ld a, 0 
f029 32 8f f5		    ld (indindex), a 
f02c			 
f02c 3e 11		    ld a, 00010001b 
f02e 32 90 f5		    ld (cspattern), a 
f031			 
f031 c3 05 f1		    jp testloop 
f034			 
f034			; ASCI routines 
f034			 
f034			; Initialize port 0 
f034			asci0init: 
f034 3e 64		    ld a, 01100100b 
f036			            ; bit 7 = 0: MPE - disabled 
f036			            ; bit 6 = 1: RE - Rx enabled 
f036			            ; bit 5 = 1: TE - Tx enabled 
f036			            ; bit 4 = 0: RTS0 - set to low, RTS active (?) 
f036			            ; bit 3 = 0: MPBR/EFR - not used 
f036			            ; bit 2 - 0 = 100 - Start + 8 bit data + 1 stop 
f036 01 00 00		    ld bc, CNTLA0 
f039 ed 79		    out (c), a 
f03b			 
f03b			    ; set Baudrate: PHI / (PS * DR * SS) = Baud Rate 
f03b			    ; 9216000 Hz / (30 * 16 * 2) = 9600 Baud 
f03b 3e 21		    ld a, 00100001b 
f03d			            ; bit 7 = 0:  MPBT - disabled 
f03d			            ; bit 6 = 0:  MP - disabled 
f03d			            ; bit 5 = 1:  CTS/PS - prescale = 30 (PS as SS2-0 are not 111) 
f03d			            ; bit 4 = 0:  PEO - ignored as no parity configured 
f03d			            ; bit 3 = 0:  DR - Clock factor = 16 
f03d			            ; bit 2 - 0 = 001:  SS2-SS0 - Divide Ratio: 2 
f03d 01 02 00		    ld bc, CNTLB0 
f040 ed 79		    out (c), a 
f042			 
f042 c9			    ret 
f043			 
f043			; Output a character on port 0 
f043			; reg E contains character to output 
f043			asci0putc: 
f043 01 04 00		    ld bc, STAT0 
f046 ed 78		    in a, (c) 
f048 e6 02		    and 00000010b    ;test bit 1 = TDRE: Transmit Data Register Empty 
f04a 28 f7		    jr z, asci0putc  ;not empty yet 
f04c 7b			    ld a, e 
f04d 01 06 00		    ld bc, TDR0 
f050 ed 79		    out (c), a       ;output character 
f052 c9			    ret 
f053			 
f053			; Input a character from port 0 
f053			; reg E contains the character 
f053			; if E == 0 no character is available 
f053			asci0getc: 
f053 1e 00		    ld e, 0 
f055 01 04 00		    ld bc, STAT0 
f058 ed 78		    in a, (c) 
f05a e6 80		    and 10000000b    ;test bit 7 = RDRF: Recieve data in FIFO 
f05c c8			    ret z            ;empty 
f05d 7b			    ld a, e 
f05e 01 08 00		    ld bc, RDR0 
f061 ed 78		    in a, (c)        ;input character 
f063 5f			    ld e, a 
f064 c9			    ret 
f065			 
f065			; Output a character string on port 0 
f065			; reg HL points to string to output 
f065			; the string is ended by 0 
f065			asci0pstr: 
f065 7e			    ld a, (hl) 
f066 b7			    or a 
f067 c8			    ret z 
f068 5e			    ld e, (hl) 
f069 23			    inc hl 
f06a cd 43 f0		    call asci0putc 
f06d 18 f6		    jr asci0pstr 
f06f			 
f06f			; Initialize port 1 
f06f			asci1init: 
f06f 3e 64		    ld a, 01100100b 
f071			            ; bit 7 = 0: MPE - disabled 
f071			            ; bit 6 = 1: RE - Rx enabled 
f071			            ; bit 5 = 1: TE - Tx enabled 
f071			            ; bit 4 = 0: RTS0 - set to low, RTS active (?) 
f071			            ; bit 3 = 0: MPBR/EFR - not used 
f071			            ; bit 2 - 0 = 100 - Start + 8 bit data + 1 stop 
f071 01 01 00		    ld bc, CNTLA1 
f074 ed 79		    out (c), a 
f076			 
f076			    ; set Baudrate: PHI / (PS * DR * SS) = Baud Rate 
f076			    ; 9216000 Hz / (30 * 16 * 2) = 9600 Baud 
f076 3e 21		    ld a, 00100001b 
f078			            ; bit 7 = 0:  MPBT - disabled 
f078			            ; bit 6 = 0:  MP - disabled 
f078			            ; bit 5 = 1:  CTS/PS - prescale = 30 (PS as SS2-0 are not 111) 
f078			            ; bit 4 = 0:  PEO - ignored as no parity configured 
f078			            ; bit 3 = 0:  DR - Clock factor = 16 
f078			            ; bit 2 - 0 = 001:  SS2-SS0 - Divide Ratio: 2 
f078 01 03 00		    ld bc, CNTLB1 
f07b ed 79		    out (c), a 
f07d			 
f07d c9			    ret 
f07e			 
f07e			; Output a character on port 1 
f07e			; reg E contains character to output 
f07e			asci1putc: 
f07e 01 05 00		    ld bc, STAT1 
f081 ed 78		    in a, (c) 
f083 e6 02		    and 00000010b    ;test bit 1 = TDRE: Transmit Data Register Empty 
f085 28 f7		    jr z, asci1putc  ;not empty yet 
f087 7b			    ld a, e 
f088 01 07 00		    ld bc, TDR1 
f08b ed 79		    out (c), a       ;output character 
f08d c9			    ret 
f08e			 
f08e			; Input a character from port 1 
f08e			; reg E contains the character 
f08e			; if E == 0 no character is available 
f08e			asci1getc: 
f08e 1e 00		    ld e, 0 
f090 01 05 00		    ld bc, STAT1 
f093 ed 78		    in a, (c) 
f095 e6 80		    and 10000000b    ;test bit 7 = RDRF: Recieve data in FIFO 
f097 c8			    ret z            ;empty 
f098 7b			    ld a, e 
f099 01 09 00		    ld bc, RDR1 
f09c ed 78		    in a, (c)        ;input character 
f09e 5f			    ld e, a 
f09f c9			    ret 
f0a0			 
f0a0			; Output a character string on port 1 
f0a0			; reg HL points to string to output 
f0a0			; the string is ended by 0 
f0a0			asci1pstr: 
f0a0 7e			    ld a, (hl) 
f0a1 b7			    or a 
f0a2 c8			    ret z 
f0a3 5e			    ld e, (hl) 
f0a4 23			    inc hl 
f0a5 cd 7e f0		    call asci1putc 
f0a8 18 f6		    jr asci1pstr 
f0aa			 
f0aa			; ledblink flashes the LED 
f0aa			; number of times in B reg 
f0aa			; using reg: a, b, hl 
f0aa			ledblink: 
f0aa 21 ff ff		    ld hl, 0xffff 
f0ad 3e 01		    ld a, 1 
f0af d3 43		    out(LEDON), a 
f0b1			ledonloop: 
f0b1 2b			    dec hl 
f0b2 7c			    ld a, h 
f0b3 b5			    or l 
f0b4 c2 b1 f0		    jp nz, ledonloop 
f0b7 21 ff ff		    ld hl, 0xffff 
f0ba 3e 00		    ld a, 0 
f0bc d3 42		    out(LEDOFF), a 
f0be			ledoffloop: 
f0be 2b			    dec hl 
f0bf 7c			    ld a, h 
f0c0 b5			    or l 
f0c1 c2 be f0		    jp nz, ledoffloop 
f0c4 10 e4		    djnz ledblink 
f0c6 c9			    ret 
f0c7			 
f0c7			; delays makes a delay multiplied 
f0c7			; by number of times in B reg 
f0c7			; using reg: a, b, hl 
f0c7			delays: 
f0c7 21 ff ff		    ld hl, 0xffff 
f0ca			delay1loop: 
f0ca 2b			    dec hl 
f0cb 7c			    ld a, h 
f0cc b5			    or l 
f0cd c2 ca f0		    jp nz, delay1loop 
f0d0 21 ff ff		    ld hl, 0xffff 
f0d3			delay2loop: 
f0d3 2b			    dec hl 
f0d4 7c			    ld a, h 
f0d5 b5			    or l 
f0d6 c2 d3 f0		    jp nz, delay2loop 
f0d9 10 ec		    djnz delays 
f0db c9			    ret 
f0dc			 
f0dc			; Test RAM 
f0dc			; reg bc: number of bytes to test 
f0dc			; reg hl: start address of test 
f0dc			; reg a; returns 0 if RAM ok, 1 if error 
f0dc			ramtest: 
f0dc 3e 00		    ld a,0		; reset error flag 
f0de 32 91 f5		    ld (ramerr),a 
f0e1			ramtstlop: 
f0e1 1e 00		    ld e,0x00 
f0e3 73			    ld (hl),e 
f0e4 7e			    ld a,(hl) 
f0e5 bb			    cp e 
f0e6 ca ee f0		    jp z,ramtstff 
f0e9 3e 01		    ld a,1 
f0eb 32 91 f5		    ld (ramerr),a 
f0ee			ramtstff: 
f0ee 1e ff		    ld e,0xff 
f0f0 73			    ld (hl),e 
f0f1 7e			    ld a,(hl) 
f0f2 bb			    cp e 
f0f3 ca fb f0		    jp z,ramtstnxt 
f0f6 3e 01		    ld a,1 
f0f8 32 91 f5		    ld (ramerr),a 
f0fb			ramtstnxt: 
f0fb 23			    inc hl 
f0fc 0b			    dec bc 
f0fd 78			    ld a,b 
f0fe b1			    or c 
f0ff 20 e0		    jr nz, ramtstlop 
f101 3a 91 f5		    ld a, (ramerr) 
f104 c9			    ret 
f105			 
f105			; Main test loop 
f105			testloop: 
f105 06 01		    ld b, 1 
f107 cd aa f0		    call ledblink 
f10a 06 01		    ld b, 1 
f10c cd c7 f0		    call delays 
f10f			 
f10f 21 de f1		    ld hl, asci0txt 
f112 cd 65 f0		    call asci0pstr 
f115 21 f8 f1		    ld hl, indicator 
f118 06 00		    ld b, 0 
f11a 3a 8f f5		    ld a, (indindex) 
f11d 4f			    ld c, a 
f11e 09			    add hl, bc 
f11f 5e			    ld e, (hl) 
f120 cd 43 f0		    call asci0putc 
f123 21 fc f1		    ld hl, built 
f126 cd 65 f0		    call asci0pstr 
f129 cd 53 f0		    call asci0getc 
f12c 7b			    ld a, e 
f12d b7			    or a 
f12e ca 3a f1		    jp z, asci0noin 
f131 cd 43 f0		    call asci0putc 
f134 21 36 f2		    ld hl, inptxt 
f137 cd 65 f0		    call asci0pstr 
f13a			asci0noin: 
f13a			 
f13a 21 eb f1		    ld hl, asci1txt 
f13d cd a0 f0		    call asci1pstr 
f140 21 f8 f1		    ld hl, indicator 
f143 06 00		    ld b, 0 
f145 3a 8f f5		    ld a, (indindex) 
f148 4f			    ld c, a 
f149 09			    add hl, bc 
f14a 5e			    ld e, (hl) 
f14b cd 7e f0		    call asci1putc 
f14e 21 fc f1		    ld hl, built 
f151 cd a0 f0		    call asci1pstr 
f154 cd 8e f0		    call asci1getc 
f157 7b			    ld a, e 
f158 b7			    or a 
f159 ca 65 f1		    jp z, asci1noin 
f15c cd 7e f0		    call asci1putc 
f15f 21 36 f2		    ld hl, inptxt 
f162 cd a0 f0		    call asci1pstr 
f165			asci1noin: 
f165			 
f165			;Indicator index for messages 
f165 3a 8f f5		    ld a, (indindex) 
f168 3c			    inc a 
f169 e6 03		    and 00000011b 
f16b 32 8f f5		    ld (indindex), a 
f16e			 
f16e			;Chip Select and reset outputs 
f16e 3a 90 f5		    ld a, (cspattern) 
f171 d3 44		    out (CSPORT), a 
f173 07			    rlca 
f174 32 90 f5		    ld (cspattern), a 
f177			 
f177			; Test RAM 
f177			 
f177			; Enable RAM in low memory 
f177 3e 01		    ld a, 1 
f179 d3 41		    out (RAMSEL), a   ; select RAM instead of EPROM from address 0 
f17b			 
f17b			; Test physical RAM 
f17b dd 21 49 f2	    ld ix, ramtsttab 
f17f			ramtloop: 
f17f dd 6e 00		    ld l, (ix + 0) 
f182 dd 66 01		    ld h, (ix + 1) 
f185 7c			    ld a, h 
f186 b5			    or l 
f187 28 47		    jr z, ramtend   ; end of test table 
f189 dd 7e 02		    ld a, (ix + 2) 
f18c 01 39 00		    ld bc, BBR 
f18f ed 79		    out (c), a 
f191			 
f191 cd 65 f0		    call asci0pstr 
f194 dd 6e 00		    ld l, (ix + 0) 
f197 dd 66 01		    ld h, (ix + 1) 
f19a cd a0 f0		    call asci1pstr 
f19d dd 6e 03		    ld l, (ix + 3) 
f1a0 dd 66 04		    ld h, (ix + 4) 
f1a3 dd 4e 05		    ld c, (ix + 5) 
f1a6 dd 46 06		    ld b, (ix + 6) 
f1a9 cd dc f0		    call ramtest 
f1ac b7			    or a 
f1ad 28 0e		    jr z, ramisok 
f1af 21 d8 f2		    ld hl, ramtxterr 
f1b2 cd 65 f0		    call asci0pstr 
f1b5 21 d8 f2		    ld hl, ramtxterr 
f1b8 cd a0 f0		    call asci1pstr 
f1bb 18 0c		    jr ramtnxt 
f1bd			ramisok: 
f1bd 21 d0 f2		    ld hl, ramtxtok 
f1c0 cd 65 f0		    call asci0pstr 
f1c3 21 d0 f2		    ld hl, ramtxtok 
f1c6 cd a0 f0		    call asci1pstr 
f1c9			ramtnxt: 
f1c9 01 07 00		    ld bc, 7 
f1cc dd 09		    add ix, bc 
f1ce 18 af		    jr ramtloop 
f1d0			ramtend: 
f1d0			 
f1d0			; Enable EPROM in low memory 
f1d0 3e 00		    ld a, 0 
f1d2 d3 40		    out (ROMSEL), a 
f1d4			 
f1d4			; Restore Bank Area 
f1d4 3e 40		    ld a, 0x40 
f1d6 01 39 00		    ld bc, BBR 
f1d9 ed 79		    out (c), a 
f1db			 
f1db c3 05 f1		    jp testloop 
f1de			 
f1de			asci0txt: 
f1de ..			    db "ASCI port 0 " 
f1ea 00			    db 0 
f1eb			asci1txt: 
f1eb ..			    db "ASCI port 1 " 
f1f7 00			    db 0 
f1f8			 
f1f8			indicator: 
f1f8 .. 2f 2d 5c	    db '|', '/', '-', '\\' 
f1fc			 
f1fc			built: 
f1fc ..			    db " Test program for Z180 computer" 
f21b			    include "tbuilt180.z80" 
f21b ..			    db ", built 2021-08-22 19:00" 
# End of file tbuilt180.z80
f233 .. 0a		    db '\r', '\n' 
f235 00			    db 0 
f236			 
f236			inptxt: 
f236 ..			    db " <- was recieved" 
f246 .. 0a		    db '\r', '\n' 
f248 00			    db 0 
f249			 
f249			; RAM test table 
f249			ramtsttab: 
f249 e3 f2		    dw ramtxt0  ;test message, end of table if NUL 
f24b 00			    db 0x00     ;BBR 
f24c 00 00		    dw 0x0000   ;logical test start address 
f24e 00 f0		    dw 0xf000   ;size of RAM block to test 
f250			 
f250 07 f3		    dw ramtxt1  ;test message 
f252 0e			    db 0x0e     ;BBR 
f253 00 10		    dw 0x1000   ;logical test start address 
f255 00 e0		    dw 0xe000   ;size of RAM block to test 
f257			 
f257 2b f3		    dw ramtxt2  ;test message 
f259 1c			    db 0x1c     ;BBR 
f25a 00 10		    dw 0x1000   ;logical test start address 
f25c 00 e0		    dw 0xe000   ;size of RAM block to test 
f25e			 
f25e 4f f3		    dw ramtxt3  ;test message 
f260 2a			    db 0x2a     ;BBR 
f261 00 10		    dw 0x1000   ;logical test start address 
f263 00 e0		    dw 0xe000   ;size of RAM block to test 
f265			 
f265 73 f3		    dw ramtxt4  ;test message 
f267 38			    db 0x38     ;BBR 
f268 00 10		    dw 0x1000   ;logical test start address 
f26a 00 e0		    dw 0xe000   ;size of RAM block to test 
f26c			 
f26c 97 f3		    dw ramtxt5  ;test message 
f26e 46			    db 0x46     ;BBR 
f26f 00 10		    dw 0x1000   ;logical test start address 
f271 00 e0		    dw 0xe000   ;size of RAM block to test 
f273			 
f273 bb f3		    dw ramtxt6  ;test message 
f275 54			    db 0x54     ;BBR 
f276 00 10		    dw 0x1000   ;logical test start address 
f278 00 e0		    dw 0xe000   ;size of RAM block to test 
f27a			 
f27a df f3		    dw ramtxt7  ;test message 
f27c 62			    db 0x62     ;BBR 
f27d 00 10		    dw 0x1000   ;logical test start address 
f27f 00 e0		    dw 0xe000   ;size of RAM block to test 
f281			 
f281 03 f4		    dw ramtxt8  ;test message 
f283 70			    db 0x70     ;BBR 
f284 00 10		    dw 0x1000   ;logical test start address 
f286 00 e0		    dw 0xe000   ;size of RAM block to test 
f288			 
f288 27 f4		    dw ramtxt9  ;test message 
f28a 7e			    db 0x7e     ;BBR 
f28b 00 10		    dw 0x1000   ;logical test start address 
f28d 00 e0		    dw 0xe000   ;size of RAM block to test 
f28f			 
f28f 4b f4		    dw ramtxt10 ;test message 
f291 8c			    db 0x8c     ;BBR 
f292 00 10		    dw 0x1000   ;logical test start address 
f294 00 e0		    dw 0xe000   ;size of RAM block to test 
f296			 
f296 6f f4		    dw ramtxt11 ;test message 
f298 9a			    db 0x9a     ;BBR 
f299 00 10		    dw 0x1000   ;logical test start address 
f29b 00 e0		    dw 0xe000   ;size of RAM block to test 
f29d			 
f29d 93 f4		    dw ramtxt12 ;test message 
f29f a8			    db 0xa8     ;BBR 
f2a0 00 10		    dw 0x1000   ;logical test start address 
f2a2 00 e0		    dw 0xe000   ;size of RAM block to test 
f2a4			 
f2a4 b7 f4		    dw ramtxt13 ;test message 
f2a6 b6			    db 0xb6     ;BBR 
f2a7 00 10		    dw 0x1000   ;logical test start address 
f2a9 00 e0		    dw 0xe000   ;size of RAM block to test 
f2ab			 
f2ab db f4		    dw ramtxt14 ;test message 
f2ad c4			    db 0xc4     ;BBR 
f2ae 00 10		    dw 0x1000   ;logical test start address 
f2b0 00 e0		    dw 0xe000   ;size of RAM block to test 
f2b2			 
f2b2 ff f4		    dw ramtxt15 ;test message 
f2b4 d2			    db 0xd2     ;BBR 
f2b5 00 10		    dw 0x1000   ;logical test start address 
f2b7 00 e0		    dw 0xe000   ;size of RAM block to test 
f2b9			 
f2b9 23 f5		    dw ramtxt16 ;test message 
f2bb e0			    db 0xe0     ;BBR 
f2bc 00 10		    dw 0x1000   ;logical test start address 
f2be 00 e0		    dw 0xe000   ;size of RAM block to test 
f2c0			 
f2c0 47 f5		    dw ramtxt17 ;test message 
f2c2 ee			    db 0xee     ;BBR 
f2c3 00 10		    dw 0x1000   ;logical test start address 
f2c5 00 e0		    dw 0xe000   ;size of RAM block to test 
f2c7			 
f2c7 6b f5		    dw ramtxt18 ;test message 
f2c9 fc			    db 0xfc     ;BBR 
f2ca 00 10		    dw 0x1000   ;logical test start address 
f2cc 00 20		    dw 0x2000   ;size of RAM block to test 
f2ce			 
f2ce 00 00		    dw 0        ;end of table 
f2d0			 
f2d0			ramtxtok: 
f2d0 ..			    db " - OK" 
f2d5 .. 0a		    db '\r', '\n' 
f2d7 00			    db 0 
f2d8			 
f2d8			ramtxterr: 
f2d8 ..			    db " - ERROR" 
f2e0 .. 0a		    db '\r', '\n' 
f2e2 00			    db 0 
f2e3			 
f2e3			ramtxt0: 
f2e3 ..			    db "Test physical RAM 0x00000 - 0x0efff" 
f306 00			    db 0 
f307			 
f307			ramtxt1: 
f307 ..			    db "Test physical RAM 0x0f000 - 0x1cfff" 
f32a 00			    db 0 
f32b			 
f32b			ramtxt2: 
f32b ..			    db "Test physical RAM 0x1d000 - 0x2afff" 
f34e 00			    db 0 
f34f			 
f34f			ramtxt3: 
f34f ..			    db "Test physical RAM 0x2b000 - 0x38fff" 
f372 00			    db 0 
f373			 
f373			ramtxt4: 
f373 ..			    db "Test physical RAM 0x39000 - 0x46fff" 
f396 00			    db 0 
f397			 
f397			ramtxt5: 
f397 ..			    db "Test physical RAM 0x47000 - 0x54fff" 
f3ba 00			    db 0 
f3bb			 
f3bb			ramtxt6: 
f3bb ..			    db "Test physical RAM 0x55000 - 0x62fff" 
f3de 00			    db 0 
f3df			 
f3df			ramtxt7: 
f3df ..			    db "Test physical RAM 0x63000 - 0x70fff" 
f402 00			    db 0 
f403			 
f403			ramtxt8: 
f403 ..			    db "Test physical RAM 0x71000 - 0x7efff" 
f426 00			    db 0 
f427			 
f427			ramtxt9: 
f427 ..			    db "Test physical RAM 0x7f000 - 0x8cfff" 
f44a 00			    db 0 
f44b			 
f44b			ramtxt10: 
f44b ..			    db "Test physical RAM 0x8d000 - 0x9afff" 
f46e 00			    db 0 
f46f			 
f46f			ramtxt11: 
f46f ..			    db "Test physical RAM 0x9b000 - 0xa8fff" 
f492 00			    db 0 
f493			 
f493			ramtxt12: 
f493 ..			    db "Test physical RAM 0xa9000 - 0xb6fff" 
f4b6 00			    db 0 
f4b7			 
f4b7			ramtxt13: 
f4b7 ..			    db "Test physical RAM 0xb7000 - 0xc4fff" 
f4da 00			    db 0 
f4db			 
f4db			ramtxt14: 
f4db ..			    db "Test physical RAM 0xc5000 - 0xd2fff" 
f4fe 00			    db 0 
f4ff			 
f4ff			ramtxt15: 
f4ff ..			    db "Test physical RAM 0xd3000 - 0xe0fff" 
f522 00			    db 0 
f523			 
f523			ramtxt16: 
f523 ..			    db "Test physical RAM 0xe1000 - 0xeefff" 
f546 00			    db 0 
f547			 
f547			ramtxt17: 
f547 ..			    db "Test physical RAM 0xef000 - 0xfcfff" 
f56a 00			    db 0 
f56b			 
f56b			ramtxt18: 
f56b ..			    db "Test physical RAM 0xfd000 - 0xfefff" 
f58e 00			    db 0 
f58f			 
f58f			; The rest of RAM is for variables 
f58f			prgend: 
f58f			 
f58f			indindex: 
f58f 00			    db 0 
f590			 
f590			cspattern: 
f590 00			    db 0 
f591			 
f591			ramerr: 
f591 00			    db 0 
f592			 
# End of file test180.z80
f592
