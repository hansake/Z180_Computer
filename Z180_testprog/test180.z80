; Test program for the Z180 computer
; test180.z80
;
; testing:
;   - simple MMU setup
;   - RAM as stack
;   - Serial output port 0 & 1
;   - Serial input port 0 & 1
;   - MMU setup with Common Bank 0, Bank Area, Common Bank 1
;   - simple RAM test
;   - copy test program to RAM and execute
;   - switch to low RAM using MEMSEL
;   - test 74LS74 select outputs
; todo
;   - test all RAM using MEMSEL
;   - interupt test

; Internal ports

; ASCI Registers port 0 and 1
CNTLA0: equ 0x0000  ;ASCI Channel Control Register A 0
CNTLA1: equ 0x0001  ;ASCI Channel Control Register A 1
CNTLB0: equ 0x0002  ;ASCI Control Register B 0
CNTLB1: equ 0x0003  ;ASCI Control Register B 1
STAT0:  equ 0x0004  ;ASCI Status Register 0
STAT1:  equ 0x0005  ;ASCI Status Register 1
TDR0:   equ 0x0006  ;ASCI Transmit Data Register 0
TDR1:   equ 0x0007  ;ASCI Transmit Data Register 1
RDR0:   equ 0x0008  ;ASCI Receive Data FIFO 0
RDR1:   equ 0x0009  ;ASCI Receive Data FIFO 1

; MMU Registers
CBR:    equ 0x0038  ;MMU Common Base Register
BBR:    equ 0x0039  ;MMU Bank Base Register
CBAR:   equ 0x003a  ;MMU Common/Bank Area Register

; External ports

;Select EPROM or RAM on address 0x0000 - 0x3ffff
ROMSEL: equ 0x40    ;Write selects EPROM (reset condition)
RAMSEL: equ 0x41    ;Write selects RAM

;LED on/off
LEDOFF: equ 0x42    ;Write turns LED off (reset condition)
LEDON:  equ 0x43    ;Write turns LED on

;SPI device select and AVR reset
CSPORT: equ 0x44    ;Write to bit 0 - 3 (reset condition, all 0)
                    ;Bit 0: select SD_CS0 when set to 1
                    ;Bit 1: select SD_CS1 when set to 1
                    ;Bit 2: select ATSS (AVR) when set to 1
                    ;Bit 1: reset AVR when set to 1
                    ;       if JP8 pin 2-3 connected


boot:

init:

; Set up the MMU
;
; Common Bank 0, 4KB
;    logical: 0x0000 - 0x0fff
;    physical: 0x00000 - 0x00fff, EPROM or start of low RAM if enabled
; Bank Area, 56KB
;    logical: 0x1000 - 0xefff
;    physical: 0x41000 - 0x4efff, low RAM chip above EPROM
; Common Bank 1, 4KB
;    logical: 0xf000 - 0xffff
;    physical: 0xff000 - 0xfffff, end of high RAM chip
;
; The MMU function is a bit mysterious but I learned that CBAR
; must be configured before CBR and BBR otherwise strange
; things will happen.

    ld a, 0xf1   ;<CA><BA>
    ld bc, CBAR
    out (c), a
    ld a, 0xf0
    ld bc, CBR
    out (c), a
    ld a, 0x40
    ld bc, BBR
    out (c), a

HIRAM: equ 0xf000

; copy the program to high RAM
    ld bc,prgend - prgstart
    ld hl,prgineprom
    ld de,HIRAM
cploop:
    ld a,b
    or c
    jp z,cpend
    ld a,(hl)
    inc hl
    ld (de),a
    inc de
    dec bc
    jp cploop
cpend:
    jp HIRAM	; jump to the copied code

prgineprom:

    org HIRAM

prgstart:

; Set up Stack Pointer (first push/call will wrap to 0xffff)
    ld sp, 0x0000

; Initialize devices
; and blink LED

    ld b, 1         ;1 blink, MMU initialized
    call ledblink
    ld b, 2
    call delays

    call asci0init
    ld b, 2         ;2 blinks, ASCI 0 initialized
    call ledblink
    ld b, 2
    call delays

    call asci1init
    ld b, 3         ;3 blinks, ASCI 1 initialized
    call ledblink
    ld b, 2
    call delays

    ld a, 0
    ld (indindex), a

    ld a, 00010001b
    ld (cspattern), a

    jp testloop

; ASCI routines

; Initialize port 0
asci0init:
    ld a, 01100100b
            ; bit 7 = 0: MPE - disabled
            ; bit 6 = 1: RE - Rx enabled
            ; bit 5 = 1: TE - Tx enabled
            ; bit 4 = 0: RTS0 - set to low, RTS active (?)
            ; bit 3 = 0: MPBR/EFR - not used
            ; bit 2 - 0 = 100 - Start + 8 bit data + 1 stop
    ld bc, CNTLA0
    out (c), a

    ; set Baudrate: PHI / (PS * DR * SS) = Baud Rate
    ; 9216000 Hz / (30 * 16 * 2) = 9600 Baud
    ld a, 00100001b
            ; bit 7 = 0:  MPBT - disabled
            ; bit 6 = 0:  MP - disabled
            ; bit 5 = 1:  CTS/PS - prescale = 30 (PS as SS2-0 are not 111)
            ; bit 4 = 0:  PEO - ignored as no parity configured
            ; bit 3 = 0:  DR - Clock factor = 16
            ; bit 2 - 0 = 001:  SS2-SS0 - Divide Ratio: 2
    ld bc, CNTLB0
    out (c), a

    ret

; Output a character on port 0
; reg E contains character to output
asci0putc:
    ld bc, STAT0
    in a, (c)
    and 00000010b    ;test bit 1 = TDRE: Transmit Data Register Empty
    jr z, asci0putc  ;not empty yet
    ld a, e
    ld bc, TDR0
    out (c), a       ;output character
    ret

; Input a character from port 0
; reg E contains the character
; if E == 0 no character is available
asci0getc:
    ld e, 0
    ld bc, STAT0
    in a, (c)
    and 10000000b    ;test bit 7 = RDRF: Recieve data in FIFO
    ret z            ;empty
    ld a, e
    ld bc, RDR0
    in a, (c)        ;input character
    ld e, a
    ret

; Output a character string on port 0
; reg HL points to string to output
; the string is ended by 0
asci0pstr:
    ld a, (hl)
    or a
    ret z
    ld e, (hl)
    inc hl
    call asci0putc
    jr asci0pstr

; Initialize port 1
asci1init:
    ld a, 01100100b
            ; bit 7 = 0: MPE - disabled
            ; bit 6 = 1: RE - Rx enabled
            ; bit 5 = 1: TE - Tx enabled
            ; bit 4 = 0: RTS0 - set to low, RTS active (?)
            ; bit 3 = 0: MPBR/EFR - not used
            ; bit 2 - 0 = 100 - Start + 8 bit data + 1 stop
    ld bc, CNTLA1
    out (c), a

    ; set Baudrate: PHI / (PS * DR * SS) = Baud Rate
    ; 9216000 Hz / (30 * 16 * 2) = 9600 Baud
    ld a, 00100001b
            ; bit 7 = 0:  MPBT - disabled
            ; bit 6 = 0:  MP - disabled
            ; bit 5 = 1:  CTS/PS - prescale = 30 (PS as SS2-0 are not 111)
            ; bit 4 = 0:  PEO - ignored as no parity configured
            ; bit 3 = 0:  DR - Clock factor = 16
            ; bit 2 - 0 = 001:  SS2-SS0 - Divide Ratio: 2
    ld bc, CNTLB1
    out (c), a

    ret

; Output a character on port 1
; reg E contains character to output
asci1putc:
    ld bc, STAT1
    in a, (c)
    and 00000010b    ;test bit 1 = TDRE: Transmit Data Register Empty
    jr z, asci1putc  ;not empty yet
    ld a, e
    ld bc, TDR1
    out (c), a       ;output character
    ret

; Input a character from port 1
; reg E contains the character
; if E == 0 no character is available
asci1getc:
    ld e, 0
    ld bc, STAT1
    in a, (c)
    and 10000000b    ;test bit 7 = RDRF: Recieve data in FIFO
    ret z            ;empty
    ld a, e
    ld bc, RDR1
    in a, (c)        ;input character
    ld e, a
    ret

; Output a character string on port 1
; reg HL points to string to output
; the string is ended by 0
asci1pstr:
    ld a, (hl)
    or a
    ret z
    ld e, (hl)
    inc hl
    call asci1putc
    jr asci1pstr

; ledblink flashes the LED
; number of times in B reg
; using reg: a, b, hl
ledblink:
    ld hl, 0xffff
    ld a, 1
    out(LEDON), a
ledonloop:
    dec hl
    ld a, h
    or l
    jp nz, ledonloop
    ld hl, 0xffff
    ld a, 0
    out(LEDOFF), a
ledoffloop:
    dec hl
    ld a, h
    or l
    jp nz, ledoffloop
    djnz ledblink
    ret

; delays makes a delay multiplied
; by number of times in B reg
; using reg: a, b, hl
delays:
    ld hl, 0xffff
delay1loop:
    dec hl
    ld a, h
    or l
    jp nz, delay1loop
    ld hl, 0xffff
delay2loop:
    dec hl
    ld a, h
    or l
    jp nz, delay2loop
    djnz delays
    ret

; Main test loop
testloop:
    ld b, 1
    call ledblink
    ld b, 1
    call delays

    ld a, 1
    out (RAMSEL), a
    ld b, 2
    call delays
    ld a, 1
    out (ROMSEL), a

    ld hl, asci0txt
    call asci0pstr
    ld hl, indicator
    ld b, 0
    ld a, (indindex)
    ld c, a
    add hl, bc
    ld e, (hl)
    call asci0putc
    ld hl, built
    call asci0pstr
    call asci0getc
    ld a, e
    or a
    jp z, asci0noin
    call asci0putc
    ld hl, inptxt
    call asci0pstr
asci0noin:

    ld hl, asci1txt
    call asci1pstr
    ld hl, indicator
    ld b, 0
    ld a, (indindex)
    ld c, a
    add hl, bc
    ld e, (hl)
    call asci1putc
    ld hl, built
    call asci1pstr
    call asci1getc
    ld a, e
    or a
    jp z, asci1noin
    call asci1putc
    ld hl, inptxt
    call asci1pstr
asci1noin:

;Indicator index for messages

    ld a, (indindex)
    inc a
    and 00000011b
    ld (indindex), a

;Chip Select and reset output
    ld a, (cspattern)
    out (CSPORT), a
    rlca
    ld (cspattern), a

    jp testloop

asci0txt:
    db "ASCI port 0 "
    db 0
asci1txt:
    db "ASCI port 1 "
    db 0

indicator:
    db '|', '/', '-', '\\'

built:
    db " Test program for Z180 computer"
    include "tbuilt180.z80"
    db '\r', '\n'
    db 0

inptxt:
    db " <- was recieved"
    db '\r', '\n'
    db 0

prgend:

indindex:
    db 0

cspattern:
    db 0

